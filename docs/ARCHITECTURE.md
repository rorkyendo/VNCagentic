# VNCagentic Architecture Documentation

## System Overview

VNCagentic is a microservices-based system that enables natural language control of desktop environments through AI-driven command generation. The architecture prioritizes clean separation of concerns, scalability, and maintainability.

## Core Principles

### 1. Pure Generative AI
- No hardcoded command mappings
- All desktop interactions dynamically generated by LLM
- Commands expressed in structured JSON format
- Fallback logic for graceful degradation

### 2. Microservices Architecture
- Loosely coupled services with defined interfaces
- Container-based deployment for portability
- Independent scaling and maintenance
- Clear service boundaries and responsibilities

### 3. Stateless Design
- Session state persisted in database
- Services can be restarted without data loss
- Horizontal scaling capability
- Cache layer for performance optimization

## System Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                        User Interface Layer                      │
├─────────────────────────────────────────────────────────────────┤
│  Frontend (Port 3000)           │  VNC Viewer (Port 6080)       │
│  - HTML/CSS/JS Chat Interface   │  - noVNC Web Client            │
│  - REST API Client              │  - Real-time Desktop View      │
│  - Session Management           │  - Mouse/Keyboard Interaction  │
└─────────────────┬───────────────┴─────────────────┬─────────────┘
                  │                                 │
                  ▼                                 ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Application Layer                            │
├─────────────────────────────────────────────────────────────────┤
│  Backend API (Port 8000)        │  VNC Agent (Port 8090)        │
│  - FastAPI Framework            │  - Command Execution API       │
│  - AI Generative Agent          │  - xdotool Integration         │
│  - Session/Message Management   │  - Desktop Environment         │
│  - Health Monitoring            │  - Screenshot Capability       │
└─────────────────┬───────────────┴─────────────────┬─────────────┘
                  │                                 │
                  ▼                                 ▼
┌─────────────────────────────────────────────────────────────────┐
│                       Data Layer                                 │
├─────────────────────────────────────────────────────────────────┤
│  PostgreSQL (Port 5432)         │  Redis Cache (Port 6379)      │
│  - Session Persistence          │  - Temporary Data Storage      │
│  - Message History               │  - Performance Optimization    │
│  - User Data Management         │  - Session State Cache         │
└─────────────────────────────────────────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────────────────────┐
│                    External Services                             │
├─────────────────────────────────────────────────────────────────┤
│  Comet API                       │  Operating System             │
│  - LLM Integration (Claude)      │  - X11 Display Server          │
│  - Natural Language Processing   │  - Application Runtime         │
│  - Command Generation            │  - File System Access          │
└─────────────────────────────────────────────────────────────────┘
```

## Service Breakdown

### Frontend Service
**Technology**: Pure HTML/CSS/JavaScript  
**Responsibility**: User interface and user experience  

**Key Components**:
- Chat interface for natural language input
- Real-time message display with auto-refresh
- Session management (create, switch, clear)
- Responsive design for multiple screen sizes
- Direct REST API communication

**Design Patterns**:
- Single Page Application (SPA) pattern
- RESTful client architecture
- Event-driven UI updates
- Progressive enhancement

### Backend API Service
**Technology**: Python FastAPI with asyncio  
**Responsibility**: Business logic and API orchestration  

**Key Components**:
```python
backend/
├── app/
│   ├── agent/              # AI generative agent
│   │   └── ai_generative_agent.py
│   ├── api/                # REST endpoints
│   │   ├── endpoints/
│   │   │   ├── simple_chat.py
│   │   │   └── sessions.py
│   │   └── router.py
│   ├── core/               # Configuration
│   │   ├── config.py
│   │   └── database.py
│   ├── database/           # Data models
│   │   └── models.py
│   └── services/           # Business logic
│       ├── session_service.py
│       └── message_service.py
└── main.py                 # Application entry point
```

**Design Patterns**:
- Dependency Injection with FastAPI
- Repository Pattern for data access
- Service Layer for business logic
- Factory Pattern for AI agent creation

### VNC Agent Service
**Technology**: Ubuntu + X11 + Python HTTP Server  
**Responsibility**: Desktop environment and command execution  

**Key Components**:
- X11 display server (DISPLAY=:1)
- xdotool for desktop automation
- HTTP API for command execution
- noVNC server for web access
- Application suite (Firefox, Calculator, etc.)

**Architecture**:
```python
vnc-agent/
├── vnc_api.py          # HTTP server for command execution (port 8090)
├── entrypoint_vnc.sh   # Container startup script
├── Dockerfile.vnc      # Container definition
└── applications/       # Desktop applications
    ├── firefox-esr     # Web browser
    ├── xcalc          # Calculator
    ├── gedit          # Text editor
    └── xterm          # Terminal
```

**VNC API Server** (`vnc_api.py`):
- **Port**: 8090
- **Protocol**: HTTP REST API
- **Purpose**: Execute xdotool commands in VNC environment
- **Endpoints**:
  - `POST /execute` - Execute shell commands
  - `POST /screenshot` - Capture desktop screenshot
- **Features**:
  - Command validation and error handling
  - CORS support for web integration
  - Environment variable management (DISPLAY=:1)
  - Process execution with timeout protection

### Database Layer
**Technology**: PostgreSQL 15 with asyncpg  
**Responsibility**: Persistent data storage  

**Schema Design**:
```sql
-- Sessions table
CREATE TABLE sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Messages table
CREATE TABLE messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id UUID REFERENCES sessions(id),
    role VARCHAR(20) NOT NULL,
    content TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_messages_session_id ON messages(session_id);
CREATE INDEX idx_messages_created_at ON messages(created_at);
```

### Cache Layer
**Technology**: Redis 7  
**Responsibility**: Performance optimization and session state  

**Usage Patterns**:
- Session state caching
- Temporary command results
- Rate limiting data
- Performance metrics

## Data Flow Architecture

### 1. Message Processing Flow
```
User Input → Frontend → Backend API → AI Agent → Command Generation
    ↓
VNC Agent ← Command Execution ← JSON Commands ← LLM Response
    ↓
Desktop Actions → Visual Feedback → User Sees Results
    ↓
Database ← Session Update ← Execution Report ← Backend API
```

### 2. AI Agent Processing Pipeline
```python
async def process_message(self, user_message: str) -> Dict[str, Any]:
    # 1. Context Building
    conversation_history = self._get_conversation_history()
    system_prompt = self._build_system_prompt()
    
    # 2. LLM Generation
    ai_response = await self._generate_ai_response(
        user_message, conversation_history, system_prompt
    )
    
    # 3. Command Extraction
    commands = self._extract_xdotool_commands(ai_response)
    
    # 4. Command Execution
    results = []
    for cmd in commands:
        result = await self._execute_xdotool_command(cmd)
        results.append(result)
    
    # 5. Response Formatting
    execution_report = self._generate_execution_report(commands, results)
    final_response = ai_response + "\n\n" + execution_report
    
    return {
        "response": final_response,
        "commands": commands,
        "results": results
    }
```

### 3. Command Execution Flow
```
Backend API → VNC Agent API → Shell Execution → xdotool → Desktop
     ↑              ↑               ↑            ↑         ↓
Response ← JSON ← stdout/stderr ← Process ← X11 ← Application
```

## AI Agent Architecture

### System Prompt Design
The AI agent uses a comprehensive system prompt that defines:

1. **Available Applications**: Firefox, Calculator, Terminal, Text Editor
2. **Command Syntax**: xdotool operations and parameters
3. **Response Format**: Structured JSON with action and commands
4. **Timing Considerations**: Sleep commands for UI synchronization
5. **Best Practices**: Direct app launch vs alt+F2 sequences

### LLM Integration Pattern
```python
class AIGenerativeAgent:
    def __init__(self, session_id: str):
        self.session_id = session_id
        self.conversation_history = []
        self.vnc_api_base = "http://vnc-agent:8090"
    
    async def _generate_ai_response(self, user_message: str) -> str:
        # Primary: Comet API for production LLM
        try:
            return await self._comet_api_generate(user_message)
        except Exception as e:
            # Fallback: Simple pattern matching
            return self._generate_simple_ai_response(user_message)
```

### Command Format Specification
```json
{
  "action": "Brief description in Indonesian",
  "commands": [
    "DISPLAY=:1 firefox-esr &",
    "sleep 5",
    "xdotool key ctrl+l",
    "sleep 1",
    "xdotool type \"search term\"",
    "xdotool key Return"
  ]
}
```

## Security Architecture

### Container Security
- Non-root user execution
- Read-only file systems where possible
- Minimal attack surface with Alpine Linux
- Resource limits and controls

### API Security
- Input validation and sanitization
- SQL injection prevention with parameterized queries
- XSS protection with proper encoding
- Rate limiting (planned for production)

### Network Security
- Container network isolation
- Service-to-service communication only
- External API calls over HTTPS
- Database access restricted to backend only

## Performance Architecture

### Scalability Patterns
```yaml
# Horizontal scaling configuration
services:
  backend:
    deploy:
      replicas: 3
      resources:
        limits:
          cpus: '1.0'
          memory: 512M
```

### Caching Strategy
- Database query result caching
- Session state in Redis
- Static asset caching in frontend
- HTTP response caching with appropriate headers

### Resource Optimization
- Async/await for I/O operations
- Connection pooling for database
- Lazy loading of components
- Efficient Docker image layers

## Monitoring Architecture

### Health Checks
```python
@app.get("/health")
async def health_check():
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow(),
        "services": {
            "database": await check_database_health(),
            "redis": await check_redis_health(),
            "vnc_agent": await check_vnc_agent_health()
        }
    }
```

### Logging Strategy
- Structured logging with JSON format
- Log levels: DEBUG, INFO, WARNING, ERROR
- Centralized log collection
- Request/response tracing

### Metrics Collection
- Response time monitoring
- Error rate tracking
- Resource utilization metrics
- Business metrics (sessions, messages)

## Deployment Architecture

### Container Orchestration
```yaml
version: '3.8'
services:
  backend:
    build: ./backend
    depends_on:
      - postgres
      - redis
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      
  vnc-agent:
    build: ./vnc-agent
    shm_size: 2gb  # Required for browser functionality
    
  postgres:
    image: postgres:15
    volumes:
      - postgres_data:/var/lib/postgresql/data
```

### Production Considerations
- Load balancing with Nginx
- SSL/TLS termination
- Database backup and recovery
- Log rotation and retention
- Resource monitoring and alerting

## Extension Points

### Adding New Applications
1. Install application in VNC agent Dockerfile
2. Update AI system prompt with new executable
3. Test command generation and execution
4. Document usage patterns

### Custom Command Types
1. Extend xdotool command vocabulary
2. Update AI prompt with new capabilities
3. Implement execution logic in VNC agent
4. Add validation and error handling

### Alternative LLM Providers
1. Implement provider interface
2. Add configuration options
3. Update AI agent to use new provider
4. Maintain fallback compatibility

---

This architecture provides a solid foundation for natural language desktop control while maintaining clean separation of concerns and scalability for future enhancements.
